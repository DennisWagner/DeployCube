# The Deploy verb was added in PowerShell v6
function Deploy-Cube {
    <#
		.SYNOPSIS
        Deploy-Cube deploys a tabular or multidimenstional cube to a SQL Server Analysis Services instance.

		.DESCRIPTION
        Deploy-Cube deploys a tabular or multidimenstional cube to a SQL Server Analysis Services instance.

		Written by (c) Dr. John Tunnicliffe, 2019 https://github.com/DrJohnT/DeployCube
		This PowerShell script is released under the MIT license http://www.opensource.org/licenses/MIT

        .PARAMETER AsDatabasePath
        Full path to your database XMLA or TMSL file which has a .asdatabase file extension (e.g. C:\Dev\YourDB\bin\Debug\YourDB.asdatabase)

        .PARAMETER DacPublishProfile
        Name of the DAC Publish Profile to be found in the same folder as your AsDatabase (e.g. YourDB.CI.publish.xml)
        You can also provide the full path to an alternative DAC Publish Profile.

        .PARAMETER TargetServerName
        Name of the target server, including instance and port if required.

        .PARAMETER TargetDatabaseName
        Normally, the database will be named the same as your AsDatabase file. However, by adding the -TargetDatabaseName parameter, you can name the database anything you like.

        .PARAMETER PreferredVersion
        Defines the preferred version of Microsoft.AnalysisServices.Deployment.exe you wish to use.  Use 'latest' for the latest version, or do not provide the parameter.

		.EXAMPLE
        Deploy-Cube -AsDatabasePath "C:\Dev\YourDB\bin\Debug\YourDB.asdatabase" -TargetServerName "YourDBServer"
    #>

	[CmdletBinding()]
	param
	(
        [String] [Parameter(Mandatory = $true)]
        $AsDatabasePath,

        [String] [Parameter(Mandatory = $true)]
        $DacPublishProfile,

        [String] [Parameter(Mandatory = $true)]
        $TargetServerName,

        [String] [Parameter(Mandatory = $false)]
        $TargetDatabaseName,

        [String] [Parameter(Mandatory = $false)]
        $PreferredVersion
	)

	$global:ErrorActionPreference = 'Stop';

    try {
        # find the specific version of Microsoft.AnalysisServices.Deployment.exe or the latest if not available
        $Version = Select-AnalysisServicesDeploymentExeVersion -PreferredVersion $PreferredVersion;
        $AnalysisServicesDeploymentExePath = Get-AnalysisServicesDeploymentExePath -Version $Version;

	    if (!(Test-Path -Path $AnalysisServicesDeploymentExePath)) {
		    Write-Error "Could not find Microsoft.AnalysisServices.Deployment.exe in order to deploy the cube AsDatabase file!";
            throw "Could not find Microsoft.AnalysisServices.Deployment.exe in order to deploy the cube AsDatabase!";
	    }

        [String]$ProductVersion = (Get-Item $AnalysisServicesDeploymentExePath).VersionInfo.ProductVersion;

	    if (!(Test-Path -Path $AsDatabasePath)) {
		    throw "AsDatabase path does not exist in $AsDatabasePath";
	    }

	    $AsDatabaseName = Split-Path $AsDatabasePath -Leaf;
	    $OriginalDbName = $AsDatabaseName -replace ".AsDatabase", ""
	    $AsDatabaseFolder = Split-Path $AsDatabasePath -Parent;
	    if ($TargetDatabaseName -eq "") {
		    $TargetDatabaseName = $OriginalDbName;
	    }

        # figure out if we have a full path to the DAC Publish Profile or just the filename of the DAC Publish Profile in the same folder as the AsDatabase
        if (Test-Path($DacPublishProfile)) {
            $AsDatabasePublishProfilePath = $DacPublishProfile;
        } else {
            try {
                $AsDatabasePublishProfilePath = Resolve-Path "$AsDatabaseFolder\$DacPublishProfile";
            } catch {
                throw "DAC Publish Profile does not exist";
            }
        }

        			# change the config files so that SSAS Deployment Wizard deploys to the correct server
		Update-AnalysisServicesConfig -DatabaseName $DatabaseName -ServerName $ServerName -AsDatabasePath "$SourceAsDatabasePath" -ModelName $ModelName;


        $ProfileName = Split-Path $AsDatabasePublishProfilePath -Leaf;

        Write-Output "Deploy-Cube resolved the following parameters:";
        Write-Output "AsDatabasePath         : $AsDatabaseName from $AsDatabaseFolder";
        Write-Output "TargetServerName   : $TargetServerName" ;
        Write-Output "TargetDatabaseName : $TargetDatabaseName";
        Write-Output "Microsoft.AnalysisServices.Deployment.exe     : $Version (v$ProductVersion) from $AnalysisServicesDeploymentExePath" ;
        Write-Output "Following output generated by Microsoft.AnalysisServices.Deployment.exe";
        Write-Output "==============================================================================";

		$global:lastexitcode = 0;

        if (!(Ping-SqlServer -ServerName $TargetServerName)) {
            throw "Server '$TargetServerName' does not exist!";
        } else {
            Write-Verbose "Deploy-Cube: Deploying cube '$TargetDatabaseName' to server '$TargetServerName' using AsDatabase file '$AsDatabasePath'";

            $ArgList = @(
                "$AsDatabasePath",
                "/s"
            );
            Invoke-ExternalCommand -Command "$AnalysisServicesDeploymentExePath" -Arguments $ArgList -PipeOutNull $true;

            # change the connection string on the newly deployed tabular instance
            $scriptFile = "DeploymentScripts\ReplaceConnectionString.xmla";
            $scriptFilePath = Join-Path $TmslScripts $scriptFile;
            if (Test-Path $scriptFilePath) {
                $TMSL = Get-Content $scriptFilePath | ConvertFrom-Json;
                $TMSL.createOrReplace.object.database = $MappedDatabaseName;
                $TMSL.createOrReplace.dataSource.description = "BuildNumber $BuildNumber Deployed by $UserName";
                $DataSourcesNode = $TMSL.createOrReplace.dataSource;
                $ConnectionString = Get-SsasSourceConnectionString -DatabaseName $DatabaseName -ConnectionString $DataSourcesNode.connectionString;
                $DataSourcesNode.connectionString = $ConnectionString;
                $DataSourcesNode.impersonationMode = "impersonateAccount";
                $SsasAccount = Get-SQLCmdVariable -name "SsasAccount";
                $SsasPassword = Get-SQLCmdVariable -name "SsasPassword";
                $DataSourcesNode.account = $SsasAccount;
                $DataSourcesNode.password = $SsasPassword;
                $TMSLPath = Join-Path $TempPath "$DatabaseName.xmla";

                $TMSL | ConvertTo-Json | set-content "$TMSLPath";
                Write-Host "Running $TMSLPath against $ServerName.$MappedDatabaseName";
                [xml]$result = Invoke-ASCmd ï¿½InputFile "$TMSLPath" -Server "$ServerName" -Database "$MappedDatabaseName";
                ProcessAsCmdXmlResult($result);
            }

        }
    } catch {
        Write-Error "Error: $_";
    }
}
